#!/usr/bin/env ruby

require 'open3'
require 'optparse'

GREEN = "\e[32m".freeze
RED = "\e[31m".freeze
RESET = "\e[0m".freeze

GLOB_PATTERNS = [
  ->(root) { "#{root}/*.*" },
  ->(root) { "#{root}.*" },
].freeze

FILE_TYPES = {
  args: { extension: '.args' },
  input: { extension: '.in' },
  output: { extension: /^\.out/ },
  error: { extension: /^\.err/ },
  status: { extension: '.status' },
}.freeze

module Enumerable
  unless method_defined?(:to_h)
    def to_h
      hash = {}
      each do |key, value|
        hash[key] = value
      end
      hash
    end
  end
end

class SmokeError < StandardError
end

class NoSuchApplicationError < SmokeError
  def initialize(name)
    super "The application #{name.inspect} does not exist."
  end
end

class NonExecutableApplicationError < SmokeError
  def initialize(name)
    super "The application #{name.inspect} is not executable."
  end
end

def run_application(application, args, input)
  command = application + args
  Open3.popen3(*command) do |stdin, stdout, stderr, wait_threads|
    stdin.write input
    stdin.close_write
    [stdout.read.strip, stderr.read.strip, wait_threads.value.exitstatus]
  end
rescue SystemCallError => errno
  create_readable_error(application, errno)
end

def create_readable_error(application, errno)
  # no case/when because === does not work on class?
  if errno.class == Errno::ENOENT
    raise NoSuchApplicationError, application[0]
  elsif errno.class == Errno::ENOEXEC
    raise NonExecutableApplicationError, application[0]
  else
    raise errno
  end
end

def read_tests(roots)
  roots.collect_concat { |root| GLOB_PATTERNS.collect_concat { |pattern| Dir.glob(pattern.call(root)) } }
    .sort
    .collect { |file| [File.basename(file, '.*'), File.extname(file), file] }
    .collect { |name, extension, file| [name, look_up_extension(extension), file] }
    .reject { |_, type, _| type.nil? }
    .group_by { |name, _, _| name }
    .collect { |name, files|
      categorized_files = files
        .collect { |_, type, file| [type, IO.read(file).strip] }
        .group_by { |type, _| type }
        .collect { |type, types_and_files| [type, types_and_files.collect { |_, file| file }] }
        .to_h
      [name, categorized_files]
    }
    .sort_by { |name, _| name }
    .collect { |name, files|
      args = (files[:args] || [''])[0].lines.collect(&:strip)
      input = (files[:input] || [''])[0]
      expected_output = files[:output] || ['']
      expected_error = files[:error] || ['']
      expected_status = (files[:status] || ['0'])[0].to_i
      [name, args, input, expected_output, expected_error, expected_status]
    }
end

def run_tests(application, tests)
  tests.each do |name, args, input, expected_output, expected_error, expected_status|
    puts name
    next failed 'no outputs provided' if expected_output.empty? && expected_error.empty?

    output, error, status = run_application application, args, input

    unless status == expected_status && expected_output.include?(output) && expected_error.include?(error)
      info = []
      info << ['args', highlight(args.join("\n"))] unless args.empty?
      info << ['input', highlight(input)] unless input.empty?
      info += add_unless(status == expected_status, status, [highlight(expected_status.to_s)], 'status')
      info += add_unless(expected_output.include?(output), output, highlighted_array(expected_output), 'output')
      info += add_unless(expected_error.include?(error), error, highlighted_array(expected_error), 'error')

      next failed(*(info.collect { |key, value| Kernel.format('%-17s %s', (key + ':'), value) }))
    end

    succeeded 'succeeded'
  end
end

def add_unless(condition, actual, expected, name)
  return [] if condition

  actual_output = ["actual #{name}", highlight(actual.to_s)]
  expected_prefix = "expected #{name}"
  subsequent_prefixes = (1...expected.length).collect { Kernel.format("%#{expected_prefix.length}s", 'or') }
  expected_prefixes = [expected_prefix] + subsequent_prefixes
  expected_output = expected_prefixes.zip(expected)
  [actual_output] + expected_output
end

def pluralize(count, singular, plural)
  count == 1 ? singular : plural
end

def print_summary
  puts
  count = @successes + @failures
  test_summary = "#{count} #{pluralize(count, 'test', 'tests')}"
  failure_summary = "#{@failures} #{pluralize(@failures, 'failure', 'failures')}"
  if @failures == 0
    puts green "#{test_summary}, #{failure_summary}"
  else
    puts red "#{test_summary}, #{failure_summary}"
  end
end

def green(string)
  if @options[:color]
    "#{GREEN}#{string}#{RESET}"
  else
    string
  end
end

def red(string)
  if @options[:color]
    "#{RED}#{string}#{RESET}"
  else
    string
  end
end

@successes = 0
def succeeded(*messages)
  puts green messages.collect { |message| '  ' + message }.join "\n"
  @successes += 1
end

@failures = 0
def failed(*messages)
  puts red messages.collect { |message| '  ' + message }.join "\n"
  @failures += 1
end

def look_up_extension(extension)
  type, = FILE_TYPES.find { |_, configuration|
    case configuration[:extension]
    when String
      extension == configuration[:extension]
    when Regexp
      extension =~ configuration[:extension]
    end
  }
  type
end

def highlighted_array(array)
  array.collect { |value| highlight(value) }
end

def highlight(text)
  highlighted = (!@options[:color] && text.include?("\e")) ? (RESET + text + RED) : text
  highlighted.gsub("\n", "\n" + (' ' * 20))
end

def parse_options
  options = {
    color: $stdout.isatty,
  }

  immediate_exit_code = 0

  parser = OptionParser.new { |opts|
    opts.banner = 'Usage: smoke [options] COMMAND TEST-DIRECTORY'

    opts.on '-c', '--[no-]color', 'Color output' do |color|
      options[:color] = color
    end

    opts.on '-h', '--help', 'Help me' do
      puts opts
      exit immediate_exit_code
    end
  }

  parser.parse!

  if ARGV.length < 2
    immediate_exit_code = 2
    parser.parse!(%w(--help))
  end
  [options, ARGV]
end

begin
  @options, @args = parse_options
  application = @args[0].split(/ /) # quick hack, does not consider blanks in file names
  run_tests(application, read_tests(@args[1...@args.length]))
  print_summary
  exit 1 if @failures > 0
rescue SmokeError => e
  $stderr.puts e.message
  exit 1
end
